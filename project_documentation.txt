Project Documentation - Sat Oct 12 19:10:53 UTC 2024
==============================

File: /home/paul/SoundScreen/control/Dockerfile
Type: Dockerfile
------------------------------
FROM node:16

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 4000
CMD [ "npm", "start" ]


File: /home/paul/SoundScreen/control/package.json
Type: JSON (Config/Package)
------------------------------
{
  "name": "soundscreen-web",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^5.2.0",
    "react-scripts": "^4.0.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}


File: /home/paul/SoundScreen/control/src/App.js
Type: JavaScript (Node/Express)
------------------------------
import React from 'react';

function App() {
  return (
    <div>
      <h1>Manager's Control Panel</h1>
      <button>Add Device</button>
    </div>
  );
}

export default App;


File: /home/paul/SoundScreen/control/src/index.js
Type: JavaScript (Node/Express)
------------------------------
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);


File: /home/paul/SoundScreen/webserver/Dockerfile
Type: Dockerfile
------------------------------
FROM node:16

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000
CMD [ "npm", "start" ]


File: /home/paul/SoundScreen/webserver/package.json
Type: JSON (Config/Package)
------------------------------
{
  "name": "soundscreen-web",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-router-dom": "^5.2.0",
    "react-scripts": "^4.0.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}


File: /home/paul/SoundScreen/webserver/src/Settings.js
Type: JavaScript (Node/Express)
------------------------------
import React, { useState } from 'react';

function Settings({ siteId }) {
  const [jsonData, setJsonData] = useState(null);

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = (event) => {
      const content = event.target.result;
      try {
        const json = JSON.parse(content);
        setJsonData(json);
      } catch (error) {
        alert('Invalid JSON file');
      }
    };
    reader.readAsText(file);
  };

  const handleSubmit = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch(`/api/sites/${siteId}/settings`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(jsonData),
    });

    if (response.ok) {
      alert('Settings updated successfully');
    } else {
      alert('Failed to update settings');
    }
  };

  return (
    <div>
      <h1>Site Settings</h1>
      <input type="file" accept="application/json" onChange={handleFileUpload} />
      <button onClick={handleSubmit}>Upload JSON</button>
      <button onClick={() => setJsonData(null)}>Cancel</button>
    </div>
  );
}

export default Settings;


File: /home/paul/SoundScreen/webserver/src/ControlPanel.js
Type: JavaScript (Node/Express)
------------------------------
import React, { useState, useEffect } from 'react';
import { useHistory } from 'react-router-dom'; // Add this line to handle routing

function ControlPanel() {
  const [site, setSite] = useState(null);
  const [areas, setAreas] = useState([]);
  const [newSiteName, setNewSiteName] = useState('');
  const [newAreaName, setNewAreaName] = useState(''); // Add newAreaName to the state
  const [message, setMessage] = useState('');
  const [subscriptionType, setSubscriptionType] = useState(''); // State to store the subscription type
  const history = useHistory(); // Add this for routing

  useEffect(() => {
    const fetchData = async () => {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/sites', {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        setSite(data.site);
        setAreas(data.areas.map((area) => ({ ...area, name: area.name }))); // Ensure each area has its own name state
        setNewSiteName(data.site.name);  // Set current site name in input
        setSubscriptionType(data.subscriptionType);
      } else {
        setMessage('Failed to load site data.');
      }
    };

    fetchData();
  }, []);

  const handleSiteRename = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch(`/api/sites/${site.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ name: newSiteName }),
    });

    if (response.ok) {
      setMessage('Site renamed successfully!');
      setSite({ ...site, name: newSiteName });
    } else {
      setMessage('Failed to rename site.');
    }
  };

  const handleAreaRename = async (areaId, newName) => {
    const token = localStorage.getItem('token');
    const response = await fetch(`/api/areas/${areaId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ name: newName }),
    });

    if (response.ok) {
      setMessage('Area renamed successfully!');
      setAreas(areas.map(area => area.id === areaId ? { ...area, name: newName } : area));
    } else {
      setMessage('Failed to rename area.');
    }
  };

  const handleAddArea = async () => {
    const token = localStorage.getItem('token');
    const response = await fetch('/api/areas', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ siteId: site.id, name: newAreaName }),
    });

    if (response.ok) {
      const data = await response.json();
      setAreas([...areas, { id: data.areaId, name: newAreaName }]);
      setNewAreaName('');  // Clear input after adding
      setMessage('Area added successfully!');
    } else {
      setMessage('Failed to add area.');
    }
  };

  const handleRemoveArea = async (areaId) => {
    const token = localStorage.getItem('token');
    const response = await fetch(`/api/areas/${areaId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (response.ok) {
      setMessage('Area removed successfully!');
      setAreas(areas.filter((area) => area.id !== areaId));
    } else {
      setMessage('Failed to remove area.');
    }
  };

  const handleAddSite = async () => {
    // Use the state for subscription type
    if (subscriptionType === 'Free' && site) {
      history.push('/subscription'); // Redirect to subscription page if limit reached
    } else {
      const token = localStorage.getItem('token');
      const response = await fetch('/api/sites', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ name: 'New Site' }),  // Default new site name
      });

      const data = await response.json();
      if (response.ok) {
        setMessage('Site added successfully!');
        window.location.reload();  // Refresh to show new site
      } else if (data.message === 'Site limit reached for your subscription tier') {
        history.push('/subscription'); // Redirect if limit is reached
      } else {
        setMessage('Failed to add site.');
      }
    }
  };

  return (
    <div>
      <h1>Manager's Control Panel</h1>
      
      {/* Display the current subscription type */}
      {subscriptionType && <h2>Subscription: {subscriptionType}</h2>}

      {site && (
        <div>
          <h2>Site: {site.name}</h2>
          <input
            type="text"
            value={newSiteName}
            onChange={(e) => setNewSiteName(e.target.value)}
          />
          <button onClick={handleSiteRename}>Rename Site</button>

          <h3>Areas</h3>
          <ul>
            {areas.map((area) => (
              <li key={area.id}>
                <input
                  type="text"
                  value={area.name}
                  onChange={(e) =>
                    setAreas(
                      areas.map((a) =>
                        a.id === area.id ? { ...a, name: e.target.value } : a
                      )
                    )
                  }
                />
                <button onClick={() => handleAreaRename(area.id, area.name)}>Rename Area</button>
                <button onClick={() => handleRemoveArea(area.id)}>Remove Area</button>
              </li>
            ))}
          </ul>
          <input
            type="text"
            value={newAreaName}
            onChange={(e) => setNewAreaName(e.target.value)}
          />
          <button onClick={handleAddArea}>Add Area</button>
        </div>
      )}

      {/* Add Site button */}
      <button onClick={handleAddSite}>Add Site</button>

      {message && <p>{message}</p>}
    </div>
  );
}

export default ControlPanel;


File: /home/paul/SoundScreen/webserver/src/SubscriptionPage.js
Type: JavaScript (Node/Express)
------------------------------
import React from 'react';
import { useHistory } from 'react-router-dom';

function SubscriptionPage() {
  const history = useHistory();

  const handleSubscriptionSelect = (subscriptionType) => {
    // Store the selected subscription in local storage or send it to the backend
    localStorage.setItem('subscriptionType', subscriptionType);

    // Redirect the user to the control panel after selecting subscription
    history.push('/control-panel');
  };

  return (
    <div>
      <h1>Select Your Subscription Plan</h1>
      <div>
        <h3>Free Plan</h3>
        <p>1 Site, 1 Area, 3 Devices</p>
        <button onClick={() => handleSubscriptionSelect('Free')}>Choose Free</button>
      </div>
      <div>
        <h3>Single Site Plan</h3>
        <p>1 Site, Unlimited Areas, 10 Devices</p>
        <button onClick={() => handleSubscriptionSelect('Single Site')}>Choose Single Site</button>
      </div>
      <div>
        <h3>Multi Site Plan</h3>
        <p>5 Sites, Unlimited Areas, 50 Devices</p>
        <button onClick={() => handleSubscriptionSelect('Multi Site')}>Choose Multi Site</button>
      </div>
      <div>
        <h3>Enterprise Plan</h3>
        <p>Unlimited Sites, Areas, and Devices</p>
        <button onClick={() => handleSubscriptionSelect('Enterprise')}>Choose Enterprise</button>
      </div>
    </div>
  );
}

export default SubscriptionPage;


File: /home/paul/SoundScreen/webserver/src/Home.js
Type: JavaScript (Node/Express)
------------------------------
import React from 'react';
import { Link } from 'react-router-dom';

function Home() {
  return (
    <div>
      <h2>SoundScreen – The Ultimate Venue Entertainment & Advertising Solution</h2>
      <p>
        Transform Your Venue’s Atmosphere with Music, Advertising, and Entertainment – All in One System.
        Enhance Your Venue with Personalized Background Music and Dynamic TV Displays.
      </p>
      <h3>Welcome to SoundScreen</h3>
      <p>
        SoundScreen is the all-in-one entertainment and advertising solution designed specifically for bars,
        restaurants, cafes, and entertainment venues. Our platform simplifies managing your venue’s atmosphere,
        ensuring a seamless experience for you and your guests.
      </p>
      <h3>Why SoundScreen?</h3>
      <p>
        SoundScreen brings together the power of customized background music and dynamic TV display advertising,
        allowing you to:
      </p>
      <ul>
        <li>Set the Mood with the Perfect Soundtrack</li>
        <li>Engage Patrons with Tailored Promotions and Advertising</li>
        <li>Host Interactive Events for Ultimate Entertainment</li>
      </ul>
      <p>
        Our system gives you full control over your venue's sound and visuals from a single, easy-to-use interface.
        Whether you're managing background music, displaying promotions, or running interactive events, SoundScreen
        takes care of it all.
      </p>
      <h3>Key Features</h3>
      <h4>1. Background Music System</h4>
      <p>
        Elevate your venue’s atmosphere with customizable background music that’s easy to manage.
      </p>
      <ul>
        <li>Integrate with Spotify or YouTube</li>
        <li>Zone Control for Different Areas</li>
        <li>Seamless Automation</li>
        <li>Guest Requests</li>
      </ul>
      <h4>2. TV Display Advertising System</h4>
      <p>
        Turn your venue’s TVs into revenue-generating tools and entertainment hubs.
      </p>
      <ul>
        <li>Promote Your Venue</li>
        <li>Dynamic Content</li>
        <li>Partner Ads for Extra Revenue</li>
        <li>Interactive Entertainment</li>
      </ul>
      <h4>3. Event Management and Scheduling</h4>
      <p>
        Planning events has never been easier with SoundScreen. Schedule and manage your events effortlessly, all while
        keeping your venue's atmosphere aligned with your events.
      </p>
      <h3>How It Works</h3>
      <ul>
        <li>Sign Up and Onboard Your Venue</li>
        <li>Connect Your Devices</li>
        <li>Personalize Your Content</li>
        <li>Sit Back and Relax</li>
      </ul>
      <h3>Testimonials from Venue Owners</h3>
      <p>
        "SoundScreen has completely changed the way we manage our bar's atmosphere. The music is always perfectly timed, 
        the ads are personalized for our guests, and the interactive events keep people coming back." – Sarah T., Bar Manager
      </p>
      <h3>Ready to Enhance Your Venue?</h3>
      <button>
        <Link to="/signup">Sign Up Today!</Link>
      </button>
    </div>
  );
}

export default Home;


File: /home/paul/SoundScreen/webserver/src/Signup.js
Type: JavaScript (Node/Express)
------------------------------
import React, { useState } from 'react';

function Signup() {
  const [organizationName, setOrganizationName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    const response = await fetch('/api/signup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ organization_name: organizationName, email, password }),
    });
    const data = await response.json();
    if (response.ok) {
      setMessage('Signup successful! You can now login.');
    } else {
      setMessage(data.message || 'Signup failed.');
    }
  };

  return (
    <div>
      <h2>Signup</h2>
      <form onSubmit={handleSubmit}>
        <div>
          <label>Organization Name:</label>
          <input
            type="text"
            value={organizationName}
            onChange={(e) => setOrganizationName(e.target.value)}
            required
          />
        </div>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <button type="submit">Signup</button>
      </form>
      {message && <p>{message}</p>}
    </div>
  );
}

export default Signup;


File: /home/paul/SoundScreen/webserver/src/App.js
Type: JavaScript (Node/Express)
------------------------------
import React from 'react';
import { BrowserRouter as Router, Route, Switch, Link, Redirect } from 'react-router-dom';
import Signup from './Signup';
import Login from './Login';
import ControlPanel from './ControlPanel';
import Home from './Home';
import SubscriptionPage from './SubscriptionPage'; // Import the subscription page

// Helper function to check if the user is authenticated
const isAuthenticated = () => {
  return !!localStorage.getItem('token');
};

// Define the PrivateRoute component
const PrivateRoute = ({ component: Component, ...rest }) => {
  return (
    <Route
      {...rest}
      render={(props) =>
        isAuthenticated() ? (
          <Component {...props} />
        ) : (
          <Redirect to="/login" />
        )
      }
    />
  );
};

// Final single App function
function App() {
  return (
    <Router>
      <nav>
        <ul>
          {!isAuthenticated() ? (
            <>
              <li><Link to="/">Home</Link></li>
              <li><Link to="/signup">Signup</Link></li>
              <li><Link to="/login">Login</Link></li>
            </>
          ) : (
            <>
              <li><Link to="/control-panel">Control Panel</Link></li>
              <li><Link to="/subscription">Subscription</Link></li>
              <li><Link to="/" onClick={() => { localStorage.removeItem('token'); window.location.reload(); }}>Sign Out</Link></li>
            </>
          )}
        </ul>
      </nav>

      <Switch>
        <Route path="/" exact component={Home} />
        <Route path="/signup" component={Signup} />
        <Route path="/login" component={Login} />
        <PrivateRoute path="/control-panel" component={ControlPanel} />
        <PrivateRoute path="/subscription" component={SubscriptionPage} /> {/* Add subscription route */}
      </Switch>
    </Router>
  );
}

export default App;


File: /home/paul/SoundScreen/webserver/src/index.js
Type: JavaScript (Node/Express)
------------------------------
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);


File: /home/paul/SoundScreen/webserver/src/Login.js
Type: JavaScript (Node/Express)
------------------------------
import React, { useState } from 'react';
import { useHistory } from 'react-router-dom';

function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [message, setMessage] = useState('');
  const history = useHistory(); // Used for redirecting

  const handleSubmit = async (e) => {
    e.preventDefault();
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    const data = await response.json();
    if (response.ok) {
      setMessage('Login successful!');
      localStorage.setItem('token', data.token); // Store JWT in localStorage
      history.push('/control-panel'); // Redirect to the control panel
    } else {
      setMessage(data.message || 'Login failed.');
    }
  };

  return (
    <div>
      <h2>Login</h2>
      <form onSubmit={handleSubmit}>
        <div>
          <label>Email:</label>
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label>Password:</label>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <button type="submit">Login</button>
      </form>
      {message && <p>{message}</p>}
    </div>
  );
}

export default Login;


File: /home/paul/SoundScreen/nginx/Dockerfile
Type: Dockerfile
------------------------------
FROM nginx:latest

# Copy nginx.conf from the host machine to the container's NGINX configuration directory
COPY ./nginx.conf /etc/nginx/nginx.conf

# Ensure SSL certificates are mounted via volumes as specified in docker-compose.yml



File: /home/paul/SoundScreen/app/Dockerfile
Type: Dockerfile
------------------------------
# Use an official Node.js image as the base
FROM node:16

# Set the working directory inside the container
WORKDIR /usr/src/app

# Install dependencies
COPY package*.json ./
RUN npm install

# Install MariaDB client (MySQL-compatible)
RUN apt-get update && apt-get install -y mariadb-client

# Copy the rest of the app's code
COPY . .

# Expose the application's port
EXPOSE 5000

# Start the app
CMD ["npm", "start"]


File: /home/paul/SoundScreen/app/package.json
Type: JSON (Config/Package)
------------------------------
{
  "name": "soundscreen-backend",
  "version": "1.0.0",
  "description": "Backend for Soundscreen project",
  "main": "index.js",
  "scripts": {
    "start": "node src/index.js"
  },
  "dependencies": {
    "bcrypt": "^5.0.1",
    "cors": "^2.8.5",
    "dotenv": "^10.0.0",
    "express": "^4.17.1",
    "jsonwebtoken": "^8.5.1",
    "mysql2": "^2.2.5"
  }
}


File: /home/paul/SoundScreen/app/src/index.js
Type: JavaScript (Node/Express)
------------------------------
require('dotenv').config();
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const cors = require('cors');
const mysql = require('mysql2');

const app = express();
app.use(cors());
app.use(express.json());

const port = 5000;

// MySQL database connection
const db = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME
});

// JWT secret
const JWT_SECRET = process.env.JWT_SECRET || 'supersecretkey';

// Middleware to protect routes
const authenticateJWT = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(403).json({ message: 'Unauthorized' });

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ message: 'Unauthorized' });
    req.user = user;
    next();
  });
};

// Signup endpoint
app.post('/api/signup', async (req, res) => {
  const { organization_name, email, password } = req.body;
  if (!organization_name || !email || !password) {
    return res.status(400).json({ message: 'All fields are required' });
  }

  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const query = 'INSERT INTO users (organization_name, email, password_hash) VALUES (?, ?, ?)';
    const [userResults] = await db.promise().execute(query, [organization_name, email, hashedPassword]);
    const userId = userResults.insertId;

    const insertSiteQuery = 'INSERT INTO sites (user_id, name) VALUES (?, ?)';
    const [siteResults] = await db.promise().execute(insertSiteQuery, [userId, 'Main Site']);
    const siteId = siteResults.insertId;

    const insertAreaQuery = 'INSERT INTO areas (site_id, name) VALUES (?, ?)';
    await db.promise().execute(insertAreaQuery, [siteId, 'Main Area']);

    const token = jwt.sign({ userId }, JWT_SECRET, { expiresIn: '1h' });
    return res.status(201).json({ message: 'User created', token });

  } catch (error) {
    console.error('Signup error:', error);
    return res.status(500).json({ message: 'Server error', error });
  }
});

// Login endpoint
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ message: 'All fields are required' });

  try {
    const [userResults] = await db.promise().execute('SELECT * FROM users WHERE email = ?', [email]);
    if (userResults.length === 0) return res.status(400).json({ message: 'Invalid credentials' });

    const user = userResults[0];
    const isValid = await bcrypt.compare(password, user.password_hash);
    if (!isValid) return res.status(400).json({ message: 'Invalid credentials' });

    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '1h' });
    return res.status(200).json({ message: 'Login successful', token });

  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json({ message: 'Server error', error });
  }
});

// Fetch the current site and areas
app.get('/api/sites', authenticateJWT, (req, res) => {
  const userId = req.user.userId;
  const siteQuery = 'SELECT * FROM sites WHERE user_id = ?';
  db.execute(siteQuery, [userId], (err, sites) => {
    if (err) return res.status(500).json({ message: 'Database error', error: err });
    if (sites.length === 0) return res.status(404).json({ message: 'No sites found for user' });

    const siteId = sites[0].id;
    const areaQuery = 'SELECT * FROM areas WHERE site_id = ?';
    db.execute(areaQuery, [siteId], (err, areas) => {
      if (err) return res.status(500).json({ message: 'Database error', error: err });
      res.status(200).json({ site: sites[0], areas });
    });
  });
});

// Add a new area
app.post('/api/areas', authenticateJWT, (req, res) => {
  const { siteId, name } = req.body;
  const insertAreaQuery = 'INSERT INTO areas (site_id, name) VALUES (?, ?)';
  db.execute(insertAreaQuery, [siteId, name], (err, results) => {
    if (err) return res.status(500).json({ message: 'Failed to add area', error: err });
    res.status(201).json({ message: 'Area added successfully!', areaId: results.insertId });
  });
});

// Rename a site
app.put('/api/sites/:siteId', authenticateJWT, (req, res) => {
  const { siteId } = req.params;
  const { name } = req.body;
  const query = 'UPDATE sites SET name = ? WHERE id = ?';
  db.execute(query, [name, siteId], (err, results) => {
    if (err) return res.status(500).json({ message: 'Database error', error: err });
    res.status(200).json({ message: 'Site renamed successfully' });
  });
});

// Rename an area
app.put('/api/areas/:areaId', authenticateJWT, (req, res) => {
  const { areaId } = req.params;
  const { name } = req.body;
  const query = 'UPDATE areas SET name = ? WHERE id = ?';
  db.execute(query, [name, areaId], (err, results) => {
    if (err) return res.status(500).json({ message: 'Database error', error: err });
    res.status(200).json({ message: 'Area renamed successfully' });
  });
});

// Delete an area
app.delete('/api/areas/:areaId', authenticateJWT, (req, res) => {
  const { areaId } = req.params;
  const query = 'DELETE FROM areas WHERE id = ?';
  db.execute(query, [areaId], (err, results) => {
    if (err) return res.status(500).json({ message: 'Database error', error: err });
    res.status(200).json({ message: 'Area deleted successfully' });
  });
});

// Add a new site with subscription check
app.post('/api/sites', authenticateJWT, (req, res) => {
  const userId = req.user.userId;
  const { name } = req.body;

  const subscriptionQuery = 'SELECT subscription_type FROM users WHERE id = ?';
  db.execute(subscriptionQuery, [userId], (err, results) => {
    if (err) return res.status(500).json({ message: 'Database error', error: err });

    const subscriptionType = results[0].subscription_type;
    const siteLimit = getSiteLimit(subscriptionType);

    const siteCountQuery = 'SELECT COUNT(*) AS siteCount FROM sites WHERE user_id = ?';
    db.execute(siteCountQuery, [userId], (err, countResult) => {
      if (err) return res.status(500).json({ message: 'Database error', error: err });
      if (countResult[0].siteCount >= siteLimit) return res.status(403).json({ message: 'Site limit reached' });

      const insertQuery = 'INSERT INTO sites (user_id, name) VALUES (?, ?)';
      db.execute(insertQuery, [userId, name], (err, results) => {
        if (err) return res.status(500).json({ message: 'Database error', error: err });
        res.status(201).json({ message: 'Site created successfully' });
      });
    });
  });
});

// Update site settings with JSON data
app.put('/api/sites/:siteId/settings', authenticateJWT, (req, res) => {
  const { siteId } = req.params;
  const settings = req.body;
  const query = 'UPDATE sites SET settings = ? WHERE id = ?';
  db.execute(query, [JSON.stringify(settings), siteId], (err, results) => {
    if (err) return res.status(500).json({ message: 'Database error', error: err });
    res.status(200).json({ message: 'Settings updated successfully' });
  });
});

// Function to determine site limits based on subscription type
const getSiteLimit = (subscriptionType) => {
  switch (subscriptionType) {
    case 'Free':
      return 1;
    case 'Single Site':
      return 1;
    case 'Multi Site':
      return 5;
    case 'Enterprise':
      return Infinity;
    default:
      return 1;
  }
};

// Start the server
app.listen(port, () => {
  console.log(`Backend running on port ${port}`);
});


File: /home/paul/SoundScreen/docker-compose.yml
Type: Docker Compose YAML
------------------------------
version: '3.8'
services:
  db:
    image: mariadb:latest
    container_name: soundscreen_db
    env_file:
      - ./db/db.env
    volumes:
      - ./db/data:/var/lib/mysql
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "3306:3306"
    networks:
      - soundscreen-net

  app:
    build: ./app
    container_name: soundscreen_app
    environment:
      - NODE_ENV=production
    ports:
      - "5000:5000"
    networks:
      - soundscreen-net
    depends_on:
      - db

  webserver:
    build: ./webserver
    container_name: soundscreen_web
    ports:
      - "3000:3000"
    networks:
      - soundscreen-net

  control:
    build: ./control
    container_name: soundscreen_control
    ports:
      - "4000:4000"
    networks:
      - soundscreen-net


  nginx:
    build: ./nginx
    container_name: soundscreen_nginx
    volumes:
      - /etc/letsencrypt/live/soundscreen.soundcheckvn.com:/etc/letsencrypt/live/soundscreen.soundcheckvn.com:ro
      - /etc/letsencrypt/archive/soundscreen.soundcheckvn.com:/etc/letsencrypt/archive/soundscreen.soundcheckvn.com:ro

    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - app
      - webserver
      - control
    networks:
      - soundscreen-net

networks:
  soundscreen-net:
    name: soundscreen-net
    driver: bridge


